Notes for the conversion of Chen-Sherman's model in PharmML
===========

The human-readable pieces are translated to PharmML via the 
http://infix2pharmml.sourceforge.net service.

Based directly off the original XPP version. There is some
bash-automation here.


```
c="perl convert.pl"
```

Heaviside function
--------


```
heavx(x):= (abs(x)+x)/(2*abs(x)+1e-5)

<ct:FunctionDefinition symbId="heavx" symbolType="real">
  <ct:Description>Function: heavx</ct:Description>
  <ct:FunctionArgument symbId="x" symbolType="real"/>
  <ct:Definition>
    <math:Equation>
      <math:Binop op="divide">
        <math:Binop op="plus">
          <math:Uniop op="abs">
            <ct:SymbRef symbIdRef="x"/>
          </math:Uniop>
          <ct:SymbRef symbIdRef="x"/>
        </math:Binop>
        <math:Binop op="plus">
          <math:Binop op="times">
            <ct:Real>2</ct:Real>
            <math:Uniop op="abs">
              <ct:SymbRef symbIdRef="x"/>
            </math:Uniop>
          </math:Binop>
          <ct:Real>1e-5</ct:Real>
        </math:Binop>
      </math:Binop>
    </math:Equation>
  </ct:Definition>
</ct:FunctionDefinition>
```



Modulus function
--------

PharmML has the `rem()` function. In case it does not accept
real-valued arguments, the following can be used.

```
modulus(a,b):=a-b*floor(a/b)

<ct:FunctionDefinition symbId="modulus" symbolType="real">
  <ct:Description>Function: modulus</ct:Description>
  <ct:FunctionArgument symbId="a" symbolType="real"/>
  <ct:FunctionArgument symbId="b" symbolType="real"/>
  <ct:Definition>
    <math:Equation>
      <math:Binop op="minus">
        <ct:SymbRef symbIdRef="a"/>
        <math:Binop op="times">
          <ct:SymbRef symbIdRef="b"/>
          <math:Uniop op="floor">
            <math:Binop op="divide">
              <ct:SymbRef symbIdRef="a"/>
              <ct:SymbRef symbIdRef="b"/>
            </math:Binop>
          </math:Uniop>
        </math:Binop>
      </math:Binop>
    </math:Equation>
  </ct:Definition>
</ct:FunctionDefinition>


Saturation function
------

```
minf(v) = 1/(1 + exp((Vm-V)/sm))

<ct:FunctionDefinition symbId="minf" symbolType="real">
  <ct:Description>Function: minf</ct:Description>
  <ct:FunctionArgument symbId="v" symbolType="real"/>
  <ct:Definition>
    <math:Equation>
      <math:Binop op="divide">
        <ct:Real>1</ct:Real>
        <math:Binop op="plus">
          <ct:Real>1</ct:Real>
          <math:Uniop op="exp">
            <math:Binop op="divide">
              <math:Binop op="minus">
                <ct:SymbRef symbIdRef="Vm"/>
                <ct:SymbRef symbIdRef="V"/>
              </math:Binop>
              <ct:SymbRef symbIdRef="sm"/>
            </math:Binop>
          </math:Uniop>
        </math:Binop>
      </math:Binop>
    </math:Equation>
  </ct:Definition>
</ct:FunctionDefinition>
```



Parameters
--------

TBD



Voltage source
-------

A square source.

```

V:=Vrest + (Vburst - Vrest)*(heav(x=rem(t, tcycle)) - heav(x=rem(t,tcycle) - toff))

<!-- V (Variable) --><ct:Variable symbId="V" symbolType="real">
  <ct:Description>Variable V</ct:Description>
  <ct:Assign>
    <math:Equation>
      <math:Binop op="plus">
        <ct:SymbRef symbIdRef="Vrest"/>
        <math:Binop op="times">
          <math:Binop op="minus">
            <ct:SymbRef symbIdRef="Vburst"/>
            <ct:SymbRef symbIdRef="Vrest"/>
          </math:Binop>
          <math:Binop op="minus">
            <math:FunctionCall>
              <ct:SymbRef symbIdRef="heav"/>
              <math:FunctionArgument symbId="x">
                <math:Equation>
                  <math:Binop op="rem">
                    <ct:SymbRef symbIdRef="t"/>
                    <ct:SymbRef symbIdRef="tcycle"/>
                  </math:Binop>
                </math:Equation>
              </math:FunctionArgument>
            </math:FunctionCall>
            <math:FunctionCall>
              <ct:SymbRef symbIdRef="heav"/>
              <math:FunctionArgument symbId="x">
                <math:Equation>
                  <math:Binop op="minus">
                    <math:Binop op="rem">
                      <ct:SymbRef symbIdRef="t"/>
                      <ct:SymbRef symbIdRef="tcycle"/>
                    </math:Binop>
                    <ct:SymbRef symbIdRef="toff"/>
                  </math:Binop>
                </math:Equation>
              </math:FunctionArgument>
            </math:FunctionCall>
          </math:Binop>
        </math:Binop>
      </math:Binop>
    </math:Equation>
  </ct:Assign>
</ct:Variable>

```


Microdomain and cytosol Ca++ concentrations
---------

```
diff(Cmd,t):= ts*(-fmd*JL - fmd*B*(Cmd - Ci))

<!-- Cmd' (ODE) --><ct:DerivativeVariable symbId="Cmd" symbolType="real">
  <ct:Description>ODE: Cmd</ct:Description>
  <ct:Assign>
    <math:Equation>
      <math:Binop op="times">
        <ct:SymbRef symbIdRef="ts"/>
        <math:Binop op="minus">
          <math:Binop op="times">
            <math:Uniop op="minus">
              <ct:SymbRef symbIdRef="fmd"/>
            </math:Uniop>
            <ct:SymbRef symbIdRef="JL"/>
          </math:Binop>
          <math:Binop op="times">
            <math:Binop op="times">
              <ct:SymbRef symbIdRef="fmd"/>
              <ct:SymbRef symbIdRef="B"/>
            </math:Binop>
            <math:Binop op="minus">
              <ct:SymbRef symbIdRef="Cmd"/>
              <ct:SymbRef symbIdRef="Ci"/>
            </math:Binop>
          </math:Binop>
        </math:Binop>
      </math:Binop>
    </math:Equation>
  </ct:Assign>
  <ct:IndependentVariable>
    <ct:SymbRef symbIdRef="t"/>
  </ct:IndependentVariable>
  <ct:InitialCondition>
    <ct:InitialValue>
      <ct:Assign>
        <ct:SymbRef symbIdRef="Cmd_init"/>
      </ct:Assign>
    </ct:InitialValue>
  </ct:InitialCondition>
</ct:DerivativeVariable>
```

```
diff(Ci,t):= ts*(-fi*JR + fv*fi*B*(Cmd - Ci) - fi*L)

<!-- Ci' (ODE) --><ct:DerivativeVariable symbId="Ci" symbolType="real">
  <ct:Description>ODE: Ci</ct:Description>
  <ct:Assign>
    <math:Equation>
      <math:Binop op="times">
        <ct:SymbRef symbIdRef="ts"/>
        <math:Binop op="minus">
          <math:Binop op="plus">
            <math:Binop op="times">
              <math:Uniop op="minus">
                <ct:SymbRef symbIdRef="fi"/>
              </math:Uniop>
              <ct:SymbRef symbIdRef="JR"/>
            </math:Binop>
            <math:Binop op="times">
              <math:Binop op="times">
                <math:Binop op="times">
                  <ct:SymbRef symbIdRef="fv"/>
                  <ct:SymbRef symbIdRef="fi"/>
                </math:Binop>
                <ct:SymbRef symbIdRef="B"/>
              </math:Binop>
              <math:Binop op="minus">
                <ct:SymbRef symbIdRef="Cmd"/>
                <ct:SymbRef symbIdRef="Ci"/>
              </math:Binop>
            </math:Binop>
          </math:Binop>
          <math:Binop op="times">
            <ct:SymbRef symbIdRef="fi"/>
            <ct:SymbRef symbIdRef="L"/>
          </math:Binop>
        </math:Binop>
      </math:Binop>
    </math:Equation>
  </ct:Assign>
  <ct:IndependentVariable>
    <ct:SymbRef symbIdRef="t"/>
  </ct:IndependentVariable>
  <ct:InitialCondition>
    <ct:InitialValue>
      <ct:Assign>
        <ct:SymbRef symbIdRef="Ci_init"/>
      </ct:Assign>
    </ct:InitialValue>
  </ct:InitialCondition>
</ct:DerivativeVariable>
```


Chain of granules
-------

```
(
$c -q "diff(N1,t):= ts*(-(3*k1*Cmd + rm1)*N1 + km1*N2 + r1*N5)"
$c -q "diff(N2,t):= ts*(3*k1*Cmd*N1 -(2*k1*Cmd + km1)*N2 + 2*km1*N3)"
$c -q "diff(N3,t):= ts*(2*k1*Cmd*N2 -(2*km1 + k1*Cmd)*N3 + 3*km1*N4)"
$c -q "diff(N4,t):= ts*(k1*Cmd*N3 - (3*km1 + u1)*N4)"
$c -q "diff(N5,t):= ts*(rm1*N1 - (r1 + rm2)*N5 + r2*N6)"
$c -q "diff(N6,t):= ts*(r3 + rm2*N5 - (rm3 + r2)*N6)"
$c -q "diff(NF,t):= ts*(u1*N4 - u2*NF)"
$c -q "diff(NR,t):= ts*(u2*NF - u3*NR)"
) > chain.xml
```


